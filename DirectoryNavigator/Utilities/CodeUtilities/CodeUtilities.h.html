<!Document html>
<html><head></head><body>#pragma once<br />///////////////////////////////////////////////////////////////////////<br />// CodeUtilities.h - small, generally useful, helper classes         //<br />// ver 1.3                                                           //<br />// Language:    C++, Visual Studio 2017                              //<br />// Application: Most Projects, CSE687 - Object Oriented Design       //<br />// Author:      Jim Fawcett, Syracuse University, CST 4-187          //<br />//              jfawcett@twcny.rr.com                                //<br />///////////////////////////////////////////////////////////////////////<br />/*<br />* Package Operations:<br />* -------------------<br />* This package provides classes:<br />* - ProcessCmdLine    extracts path, options, patterns, and a number from command line<br />* - Converter&lt;<br />* - Box&lt;<br />* - PersistFactory&lt;<br />*<br />* Build Process:<br />* --------------<br />* Required Files: <br />*   CodeUtilities.h<br />*<br />* Maintenance History:<br />* --------------------<br />* ver 1.3 : 16 Aug 2018<br />* - added default usage text<br />* ver 1.2 : 11 Aug 2018<br />* - added ProcessCmdLine::hasOption method<br />* - fixed bugs in ProcessCmdLine::showCmdLine<br />*   and ProcessCmdLine::showOptions<br />* ver 1.1 : 10 Aug 2018<br />* - added ProcessCmdLine class<br />* ver 1.0 : 12 Jan 2018<br />* - first release<br />* - refactored from earlier Utilities.h<br />*<br />* Notes:<br />* ------<br />* - Designed to provide all functionality in header file. <br />* - Implementation file only needed for test and demo.<br />*<br />* Planned Additions and Changes:<br />* ------------------------------<br />* - none yet<br />*/<br /><br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include &lt;<br /><br />namespace Utilities<br />{<br />  /////////////////////////////////////////////////////////////////////<br />  // preface function<br />  // - used to add a string preface to an output, e.g., "\n  "<br /><br />  inline void preface(const std::string& msg = "", bool doReturn = true, std::ostream& out = std::cout, const std::string& prefix = "  ")<br />  {<br />    if (doReturn) out &lt;<br />  }<br /><br />  inline std::string defaultUsage()<br />  {<br />    std::string usage;<br />    usage += "\n  Command Line: path [/option]* [/pattern]* [integer]";<br />    usage += "\n    path is relative or absolute path where processing begins";<br />    usage += "\n    [/option]* are one or more options of the form /s, /r, etc.";<br />    usage += "\n    [pattern]* are one or more pattern strings used for matching";<br />    usage += "\n    [integer] is the maximum number of items to process";<br />    usage += "\n";<br />    return usage;<br />  }<br /><br />  /////////////////////////////////////////////////////////////////////<br />  // ProcessCmdLine class<br />  // - extracts path, patterns, options, number<br /><br />  class ProcessCmdLine<br />  {<br />  public:<br />    using Usage = std::string;<br />    using Path = std::string;<br />    using Option = int;<br />    using Options = std::vector&lt;<br />    using Pattern = std::string;<br />    using Patterns = std::vector&lt;<br />    using Number = long int;<br /><br />    ProcessCmdLine(int argc, char** argv, std::ostream& out = std::cout);<br />    ProcessCmdLine(const ProcessCmdLine&) = delete;<br />    ProcessCmdLine& operator=(const ProcessCmdLine&) = delete;<br /><br />    bool parseError();<br />    Path path();<br />    void path(const Path& path);<br />    Options options();<br />    void option(Option op);<br />    bool hasOption(Option op);<br />    Patterns patterns();<br />    void pattern(const Pattern& patt);<br />    Number maxItems();<br />    void maxItems(Number number);<br />    void usage(const Usage& usage);<br />    void usage();<br />    void showCmdLine(int argc, char** argv);<br />    void showCmdLine();<br />    void showPath();<br />    void showOptions();<br />    void showPatterns();<br />    void showMaxItems();<br />  private:<br />    Usage usage_;<br />    Path path_;<br />    Patterns patterns_;<br />    Options options_;<br />    int maxItems_ = 0;<br />    bool parseError_ = false;<br />    std::ostream& out_;<br />  };<br /><br />  /*----&lt;<br /><br />  inline void ProcessCmdLine::path(const Path& path) <br />  { <br />    path_ = path; <br />  }<br /><br />  inline ProcessCmdLine::Path ProcessCmdLine::path()<br />  {<br />    return path_;<br />  }<br /><br />  inline void ProcessCmdLine::showPath()<br />  {<br />    out_ &lt;<br />  }<br /><br />  /*----&lt;<br /><br />  inline void ProcessCmdLine::option(Option option)<br />  {<br />    options_.push_back(option);<br />  }<br /><br />  inline ProcessCmdLine::Options ProcessCmdLine::options()<br />  { <br />    return options_; <br />  }<br /><br />  inline bool ProcessCmdLine::hasOption(Option op)<br />  {<br />    for (auto item : options_)<br />    {<br />      if (item == op)<br />      {<br />        return true;<br />      }<br />    }<br />    return false;<br />  }<br /><br />  inline void ProcessCmdLine::showOptions()<br />  {<br />    for (auto opt : options_)<br />    {<br />      out_ &lt;<br />    }<br />  }<br /><br />  /*----&lt;<br /><br />  inline void ProcessCmdLine::pattern(const Pattern& pattern)<br />  {<br />    patterns_.push_back(pattern);<br />  }<br /><br />  inline ProcessCmdLine::Patterns ProcessCmdLine::patterns()<br />  {<br />    return patterns_;<br />  }<br /><br />  inline void ProcessCmdLine::showPatterns()<br />  {<br />    for (auto patt : patterns_)<br />    {<br />      out_ &lt;<br />    }<br />  }<br /><br />  /*----&lt;<br /><br />  inline void ProcessCmdLine::maxItems(Number maxItems)<br />  {<br />    maxItems_ = maxItems;<br />  }<br /><br />  inline ProcessCmdLine::Number ProcessCmdLine::maxItems()<br />  {<br />    return maxItems_;<br />  }<br /><br />  inline void ProcessCmdLine::showMaxItems()<br />  {<br />    if(maxItems_ != 0)<br />      out_ &lt;<br />  }<br /><br />  /*----&lt;<br /><br />  inline bool ProcessCmdLine::parseError()<br />  {<br />    return parseError_;<br />  }<br /><br />  /*----&lt;<br /><br />  inline ProcessCmdLine::ProcessCmdLine(int argc, char** argv, std::ostream& out) : out_(out)<br />  {<br />    //usage_ = defaultUsage();<br />    if (argc &lt;<br />    {<br />      out &lt;<br />      //usage();<br />      parseError_ = true;<br />      return;<br />    }<br /><br />    path_ = argv[1];<br /><br />    for (int i = 2; i &lt;<br />    {<br />      if (argv[i][0] == '/')<br />      {<br />        if (strlen(argv[i]) &gt;<br />          continue;<br />        options_.push_back(argv[i][1]);<br />      }<br />      else<br />      {<br />        int number = atoi(argv[i]);<br />        if (number &gt;<br />        {<br />          maxItems_ = number;<br />        }<br />        else<br />        {<br />          patterns_.push_back(argv[i]);<br />        }<br />      }<br />    }<br />  }<br /><br />  inline void ProcessCmdLine::showCmdLine(int argc, char** argv)<br />  {<br />    if (argc &gt;<br />    {<br />      out_ &lt;<br />      return;<br />    }<br />    for (int i = 0; i &lt;<br />    {<br />      if (argv[i] == "0")<br />        continue;<br />      if(argv[i][0] == '/')<br />      { <br />        out_ &lt;<br />      }<br />      else<br />      {<br />        out_ &lt;<br />      }<br />    }<br />  }<br /><br />  inline void ProcessCmdLine::showCmdLine()<br />  {<br />    if (path_ == "" && options_.size() == 0 && patterns_.size() == 0)<br />    {<br />      out_ &lt;<br />      return;<br />    }<br />    showPath();<br />    preface("", false);<br />    showOptions();<br />    preface("", false);<br />    showPatterns();<br />    preface("", false);<br />    showMaxItems();<br />  }<br /><br />  inline void ProcessCmdLine::usage(const Usage& usage)<br />  {<br />    usage_ = usage;<br />  }<br /><br />  inline void ProcessCmdLine::usage()<br />  {<br />    out_ &lt;<br />  }<br /><br />  /////////////////////////////////////////////////////////////////////<br />  // Converter class<br />  // - supports converting unspecified types to and from strings<br />  // - a type is convertible if it provides insertion and extraction<br />  //   operators<br /><br />  template &lt;<br />  class Converter<br />  {<br />  public:<br />    static std::string toString(const T& t);<br />    static T toValue(const std::string& src);<br />  };<br />  //----&lt;<br /><br />  template &lt;<br />  std::string Converter&lt;<br />  {<br />    std::ostringstream out;<br />    out &lt;<br />    return out.str();<br />  }<br />  //----&lt;<br />  /*<br />  *  - the string must have been generated by Converter&lt;<br />  *  - T::operator&gt;<br />  */<br />  template&lt;<br />  T Converter&lt;<br />  {<br />    std::istringstream in(src);<br />    T t;<br />    in &gt;<br />    return t;<br />  }<br /><br />  ///////////////////////////////////////////////////////////////////////<br />  // Box class<br />  // - wraps primitive type in class<br />  // - preserves primitive syntax<br /><br />  template&lt;<br />  class Box<br />  {<br />  public:<br />    Box() : primitive_(T()) {}<br />    Box(const T& t) : primitive_(t) {}<br />    operator T&() { return primitive_; }<br />    T& operator=(const T& t) { primitive_ = t; return primitive_; }<br />  private:<br />    T primitive_;<br />  };<br /><br />  ///////////////////////////////////////////////////////////////////////<br />  // ToXml interface<br />  // - defines language for creating XML elements<br /><br />  struct ToXml<br />  {<br />    virtual std::string toXml(const std::string& tag) = 0;<br />    virtual ~ToXml() {};<br />  };<br /><br />  ///////////////////////////////////////////////////////////////////////<br />  // PersistFactory&lt;<br />  // - wraps an instance of user-defined type<br />  // - preserves semantics of user-defined type<br />  // - adds toXml("tag") method<br /><br />  template&lt;<br />  class PersistFactory : public T, ToXml<br />  {<br />  public:<br />    PersistFactory() = default;<br />    PersistFactory(const T& t)<br />    {<br />      T::operator=(t);<br />    }<br />    std::string toXml(const std::string& tag)<br />    {<br />      std::ostringstream out;<br />      out &lt;<br />      return out.str();<br />    }<br />  };<br />}<br /></body>/html