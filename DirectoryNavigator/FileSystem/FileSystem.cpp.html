<!Document html>
<html><head></head><body>/////////////////////////////////////////////////////////////////////////////<br />// FileSystem.cpp - Support file and directory operations                  //<br />// ver 2.8                                                                 //<br />// ----------------------------------------------------------------------- //<br />// copyright © Jim Fawcett, 2012                                           //<br />// All rights granted provided that this notice is retained                //<br />// ----------------------------------------------------------------------- //<br />// Language:    Visual C++, Visual Studio 2010                             //<br />// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      //<br />// Application: Summer Projects, 2012                                      //<br />// Author:      Jim Fawcett, CST 4-187, Syracuse University                //<br />//              (315) 443-3948, jfawcett@twcny.rr.com                      //<br />/////////////////////////////////////////////////////////////////////////////<br /><br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include &lt;<br />#include "FileSystem.h"<br /><br />using namespace FileSystem;<br /><br />/////////////////////////////////////////////////////////<br />// helper FileSystemSearch<br /><br />class FileSystemSearch<br />{<br />public:<br />  FileSystemSearch();<br />  ~FileSystemSearch();<br />  std::string firstFile(const std::string& path=".", const std::string& pattern="*.*");<br />  std::string nextFile();<br />  std::string firstDirectory(const std::string& path=".", const std::string& pattern="*.*");<br />  std::string nextDirectory();<br />  void close();<br />private:<br />  HANDLE hFindFile;<br />  WIN32_FIND_DATAA FindFileData;<br />  WIN32_FIND_DATAA* pFindFileData;<br />};<br /><br />FileSystemSearch::FileSystemSearch() : pFindFileData(&FindFileData) {}<br />FileSystemSearch::~FileSystemSearch() { ::FindClose(hFindFile); }<br />void FileSystemSearch::close() { ::FindClose(hFindFile); }<br /><br />//----&lt;<br /><br />Block::Block(Byte* beg, Byte* end) : bytes_(beg, end) {}<br /><br />//----&lt;<br /><br />void Block::push_back(Byte b)<br />{<br />  bytes_.push_back(b);<br />}<br />//----&lt;<br /><br />Byte& Block::operator[](size_t i)<br />{<br />  if(i&lt;<br />    throw std::runtime_error("index out of range in Block");<br />  return bytes_[i];<br />}<br />//----&lt;<br /><br />Byte Block::operator[](size_t i) const<br />{<br />  if(i&lt;<br />    throw std::runtime_error("index out of range in Block");<br />  return bytes_[i];<br />}<br />//----&lt;<br /><br />bool Block::operator==(const Block& block) const<br />{<br />  return bytes_ == block.bytes_;<br />}<br />//----&lt;<br /><br />bool Block::operator!=(const Block& block) const<br />{<br />  return bytes_ != block.bytes_;<br />}<br />//----&lt;<br /><br />size_t Block::size() const<br />{<br />  return bytes_.size();<br />}<br /><br />//----&lt;<br /><br />File::File(const std::string& filespec) <br />    : name_(filespec), pIStream(nullptr), pOStream(nullptr), dirn_(in), typ_(text), good_(true)<br />{<br />}<br />//----&lt;<br /><br />File::~File() <br />{ <br />  if(pIStream)<br />  {<br />    pIStream-&gt;<br />    delete pIStream;<br />    pIStream = nullptr;<br />    good_ = false;<br />  }<br />  if(pOStream)<br />  {<br />    pOStream-&gt;<br />    delete pOStream; <br />    pOStream = nullptr;<br />    good_ = false;<br />  }<br />}<br />//----&lt;<br /><br />bool File::open(direction dirn, type typ)<br />{<br />  dirn_ = dirn;<br />  typ_ = typ;<br />  good_ = true;<br />  if(dirn == in)<br />  {<br />    pIStream = new std::ifstream;<br />    if(typ == binary)<br />      pIStream-&gt;<br />    else<br />      pIStream-&gt;<br />    if (!(*pIStream).good())<br />    {<br />      good_ = false;<br />      pIStream = nullptr;<br />      //throw std::runtime_error("\n  open for input failed in File constructor");<br />    }<br />  }<br />  else<br />  {<br />    pOStream = new std::ofstream;<br />    if(typ == binary)<br />      pOStream-&gt;<br />    else<br />      pOStream-&gt;<br />    if (!(*pOStream).good())<br />    {<br />      good_ = false;<br />      pOStream = nullptr;<br />      //throw std::runtime_error("\n  open for output failed in File constructor");<br />    }<br />  }<br />  return good_;<br />}<br />//----&lt;<br /><br />std::string File::getLine(bool keepNewLines)<br />{<br />  if(pIStream == nullptr || !pIStream-&gt;<br />    throw std::runtime_error("input stream not open");<br />  if(typ_ == binary)<br />    throw std::runtime_error("getting text line from binary file");<br />  if(dirn_ == out)<br />    throw std::runtime_error("reading output file");<br /><br />  std::string store;<br />  while (true)<br />  {<br />    char ch = pIStream-&gt;<br />    if (!isGood())<br />      return store;<br />    if (ch == '\n')<br />    {<br />      if (keepNewLines)<br />        store += ch;<br />      return store;<br />    }<br />    store += ch;<br />  }<br />}<br />//----&lt;<br /><br />std::string File::readAll(bool keepNewLines)<br />{<br />  std::string store;<br />  while (true)<br />  {<br />    if (!isGood())<br />      return store;<br />    store += getLine(keepNewLines);<br />    std::locale loc;<br />    if (store.size() &gt;<br />      store += ' ';<br />  }<br />  return store;<br />}<br />//----&lt;<br /><br />void File::putLine(const std::string& s, bool wantReturn)<br />{<br />  if(pOStream == nullptr || !pOStream-&gt;<br />    throw std::runtime_error("output stream not open");<br />  if(typ_ == binary)<br />    throw std::runtime_error("writing text line to binary file");<br />  if(dirn_ == in)<br />    throw std::runtime_error("writing input file");<br />  for(size_t i=0; i&lt;<br />    pOStream-&gt;<br />  if(wantReturn)<br />    pOStream-&gt;<br />  pOStream-&gt;<br />}<br />//----&lt;<br /><br />Block File::getBlock(size_t size)<br />{<br />  if(pIStream == nullptr || !pIStream-&gt;<br />    throw std::runtime_error("input stream not open");<br />  if(typ_ != binary)<br />    throw std::runtime_error("reading binary from text file");<br />  if(dirn_ == out)<br />    throw std::runtime_error("reading output file");<br />  Block blk;<br />  if(pIStream)<br />  {<br />    for(size_t i=0; i&lt;<br />    {<br />      Byte b;<br />      pIStream-&gt;<br />      if(pIStream-&gt;<br />        blk.push_back(b);<br />      else<br />        break;<br />    }<br />  }<br />  return blk;<br />}<br />//----&lt;<br /><br />void File::putBlock(const Block& blk)<br />{<br />  if(pOStream == nullptr || !pOStream-&gt;<br />    throw std::runtime_error("output stream not open");<br />  if(typ_ != binary)<br />    throw std::runtime_error("writing binary to text file");<br />  if(dirn_ == in)<br />    throw std::runtime_error("writing input file");<br />  if(!pOStream-&gt;<br />    return;<br />  for(size_t i=0; i&lt;<br />  {<br />    pOStream-&gt;<br />  }<br />}<br />//----&lt;<br /><br />size_t File::getBuffer(size_t bufLen, File::byte* buffer)<br />{<br />  if (pIStream == nullptr || !pIStream-&gt;<br />    throw std::runtime_error("input stream not open");<br />  if (typ_ != binary)<br />    throw std::runtime_error("reading binary from text file");<br />  if (dirn_ == out)<br />    throw std::runtime_error("reading output file");<br />  size_t count = 0;<br />  while (pIStream-&gt;<br />  {<br />    buffer[count++] = pIStream-&gt;<br />      if (count == bufLen)<br />        break;<br />  }<br />  if (!pIStream-&gt;<br />    --count;<br />  return count;<br />}<br />//----&lt;<br /><br />void File::putBuffer(size_t bufLen, File::byte* buffer)<br />{<br />  if (pOStream == nullptr || !pOStream-&gt;<br />    throw std::runtime_error("output stream not open");<br />  if (typ_ != binary)<br />    throw std::runtime_error("writing binary to text file");<br />  if (dirn_ == in)<br />    throw std::runtime_error("writing input file");<br />  if (!pOStream-&gt;<br />    return;<br />  size_t count = 0;<br />  while(pOStream-&gt;<br />  {<br />    pOStream-&gt;<br />    if (count == bufLen)<br />      break;<br />  }<br />}<br />//----&lt;<br /><br />bool File::isGood()<br />{<br />  if(!good_)<br />    return false;<br />  if(pIStream != nullptr)<br />    return (good_ = pIStream-&gt;<br />  if(pOStream != nullptr)<br />    return (good_ = pOStream-&gt;<br />  return (good_ = false);<br />}<br />//----&lt;<br /><br />void File::flush()<br />{<br />  if(pOStream != nullptr && pOStream-&gt;<br />    pOStream-&gt;<br />}<br />//----&lt;<br /><br />void File::clear()<br />{<br />  if(pIStream != nullptr)<br />    pIStream-&gt;<br />  if(pOStream != nullptr)<br />    pOStream-&gt;<br />}<br />//----&lt;<br /><br />void File::close()<br />{<br />  File::flush();<br />  if (pIStream != nullptr)<br />  {<br />    pIStream-&gt;<br />    pIStream = nullptr;<br />    good_ = false;<br />  }<br />  if (pOStream)<br />  {<br />    pOStream-&gt;<br />    pOStream = nullptr;<br />    good_ = false;<br />  }<br />}<br />//----&lt;<br /><br />bool File::exists(const std::string& file)<br />{<br />  return ::GetFileAttributesA(file.c_str()) != INVALID_FILE_ATTRIBUTES;<br />}<br />//----&lt;<br /><br />bool File::copy(const std::string& src, const std::string& dst, bool failIfExists)<br />{<br />  return ::CopyFileA(src.c_str(), dst.c_str(), failIfExists) != 0;<br />}<br />//----&lt;<br /><br />bool File::remove(const std::string& file)<br />{<br />  return ::DeleteFileA(file.c_str()) != 0;<br />}<br />//----&lt;<br /><br />FileInfo::FileInfo(const std::string& fileSpec)<br />{<br />  hFindFile = ::FindFirstFileA(fileSpec.c_str(), &data);<br />  if(hFindFile == INVALID_HANDLE_VALUE)<br />    good_ = false;<br />  else<br />    good_ = true;<br />}<br />//----&lt;<br /><br />FileInfo::~FileInfo()<br />{<br />  ::FindClose(hFindFile);<br />}<br />//----&lt;<br /><br />bool FileInfo::good()<br />{<br />  return good_;<br />}<br />//----&lt;<br /><br />std::string FileInfo::name() const<br />{<br />  return Path::getName(data.cFileName);<br />}<br />//----&lt;<br /><br />std::string FileInfo::intToString(long i)<br />{<br />  std::ostringstream out;<br />  out.fill('0');<br />  out &lt;<br />  return out.str();<br />}<br />//----&lt;<br /><br />std::string FileInfo::date(dateFormat df) const<br />{<br />  std::string dateStr, timeStr;<br />  FILETIME ft;<br />  SYSTEMTIME st;<br />  ::FileTimeToLocalFileTime(&data.ftLastWriteTime, &ft);<br />  ::FileTimeToSystemTime(&ft, &st);<br />  dateStr = intToString(st.wMonth) + '/' + intToString(st.wDay) + '/' + intToString(st.wYear);<br />  timeStr = intToString(st.wHour) + ':' + intToString(st.wMinute) + ':' + intToString(st.wSecond);<br />  if(df == dateformat)<br />    return dateStr;<br />  if(df == timeformat)<br />    return timeStr;<br />  return dateStr + " " + timeStr;<br />}<br />//----&lt;<br /><br />size_t FileInfo::size() const<br />{<br />  return (size_t)(data.nFileSizeLow + (data.nFileSizeHigh &lt;<br />}<br />//----&lt;<br /><br />bool FileInfo::isArchive() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isCompressed() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isDirectory() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isEncrypted() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isHidden() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isNormal() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isOffLine() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isReadOnly() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isSystem() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::isTemporary() const<br />{<br />  return (data.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::operator&lt;<br />{<br />  return strcmp(data.cFileName, fi.data.cFileName) == -1;<br />}<br />//----&lt;<br /><br />bool FileInfo::operator==(const FileInfo& fi) const<br />{<br />  return strcmp(data.cFileName, fi.data.cFileName) == 0;<br />}<br />//----&lt;<br /><br />bool FileInfo::operator&gt;<br />{<br />  return strcmp(data.cFileName, fi.data.cFileName) == 1;<br />}<br />//----&lt;<br /><br />bool FileInfo::earlier(const FileInfo& fi) const<br />{<br />  FILETIME ft1 = data.ftLastWriteTime;<br />  FILETIME ft2 = fi.data.ftLastWriteTime;<br />  return ::CompareFileTime(&ft1, &ft2) == -1;<br />}<br />//----&lt;<br /><br />bool FileInfo::later(const FileInfo& fi) const<br />{<br />  FILETIME ft1 = data.ftLastWriteTime;<br />  FILETIME ft2 = fi.data.ftLastWriteTime;<br />  return ::CompareFileTime(&ft1, &ft2) == 1;<br />}<br />//----&lt;<br /><br />bool FileInfo::smaller(const FileInfo &fi) const<br />{<br />  return size() &lt;<br />}<br />//----&lt;<br /><br />bool FileInfo::larger(const FileInfo &fi) const<br />{<br />  return size() &gt;<br />}<br />//----&lt;<br /><br />std::string Path::toLower(const std::string& src)<br />{<br />  std::string temp;<br />  for(size_t i=0; i&lt;<br />    temp += tolower(src[i]);<br />  return temp;<br />}<br />//----&lt;<br /><br />  <br />std::string Path::toUpper(const std::string& src)<br />{<br />  std::string temp;<br />  for(size_t i=0; i&lt;<br />    temp += toupper(src[i]);<br />  return temp;<br />}<br />//----&lt;<br /><br />std::string Path::getName(const std::string &fileSpec, bool withExt)<br />{<br />  size_t pos = fileSpec.find_last_of("/");<br />  if(pos &gt;<br />  {<br />    pos = fileSpec.find_last_of("\\");<br />    if(pos &gt;<br />    {<br />      // no path prepended<br />      if(withExt)<br />        return fileSpec;<br />      else<br />      {<br />        // remove ext<br />        size_t pos = fileSpec.find(".");<br />        if(pos &gt;<br />          return fileSpec;<br />        return fileSpec.substr(0, pos-1);<br />      }<br />    }<br />  }<br />  if(withExt)<br />    return fileSpec.substr(pos+1,fileSpec.length()-pos);<br />  else<br />  {<br />    // remove ext<br />    size_t pos2 = fileSpec.find(".", pos);<br />    if(pos2 &gt;<br />      // no ext<br />      return fileSpec.substr(pos+1);<br />    return fileSpec.substr(pos+1, pos2-pos-1);<br />  }<br />}<br />//----&lt;<br />  <br />std::string Path::getExt(const std::string& fileSpec)<br />{<br />  size_t pos1 = fileSpec.find_last_of('/');<br />  size_t pos2 = fileSpec.find_last_of('\\');<br />  size_t pos = fileSpec.find_last_of('.');<br />  // handle ../ or ..\\ with no extension<br />  if(pos1 &lt;<br />  {<br />    if(pos &lt;<br />      return std::string("");<br />  }<br />  // only . is extension delimiter<br />  if(0 &lt;<br />    return toLower(fileSpec.substr(pos+1,fileSpec.length()-pos));<br />  return std::string("");<br />}<br />//----&lt;<br /><br />std::string Path::getPath(const std::string &fileSpec)<br />{<br />  size_t pos = fileSpec.find_last_of("/");<br />  if(pos &gt;<br />    pos = fileSpec.find_last_of("\\");<br />  if(pos &gt;<br />    return ".";<br />  if(fileSpec.find(".",pos+1))<br />    return fileSpec.substr(0,pos+1);<br />  return fileSpec;<br />}<br />//----&lt;<br /><br />std::string Path::getFullFileSpec(const std::string &fileSpec)<br />{<br />  const size_t BufSize = 256;<br />  char buffer[BufSize];<br />  char filebuffer[BufSize];  // don't use but GetFullPathName will<br />  char* name = filebuffer;<br />  ::GetFullPathNameA(fileSpec.c_str(),BufSize, buffer, &name);<br />  return std::string(buffer);<br />}<br />//----&lt;<br /><br />std::string Path::fileSpec(const std::string &path, const std::string &name)<br />{<br />  std::string fs;<br />  size_t len = path.size();<br />  if(path[len-1] == '/' || path[len-1] == '\\')<br />    fs = path + name;<br />  else<br />  {<br />    if(path.find("/") &lt;<br />      fs = path + "/" + name;<br />    else if(path.find("\\") &lt;<br />      fs = path + "\\" + name;<br />    else<br />      fs = path + "/" + name;<br />  }<br />  return fs;<br />}<br />//----&lt;<br /><br />std::string Directory::getCurrentDirectory()<br />{<br />  char buffer[MAX_PATH];<br />  ::GetCurrentDirectoryA(MAX_PATH,buffer);<br />  return std::string(buffer);<br />}<br />//----&lt;<br /><br />bool Directory::setCurrentDirectory(const std::string& path)<br />{<br />  return ::SetCurrentDirectoryA(path.c_str()) != 0;<br />}<br />//----&lt;<br /><br />std::vector&lt;<br />{<br />  std::vector&lt;<br />  FileSystemSearch fss;<br />  std::string file = fss.firstFile(path, pattern);<br />  if(file.size() == 0)<br />    return files;<br />  files.push_back(file);<br />  while(true)<br />  {<br />    file = fss.nextFile();<br />    if(file.size() == 0)<br />      return files;<br />    files.push_back(file);<br />  }<br />  return files;<br />}<br />//----&lt;<br /><br />std::vector&lt;<br />{<br />  std::vector&lt;<br />  FileSystemSearch fss;<br />  std::string dir = fss.firstDirectory(path, pattern);<br />  if(dir.size() == 0)<br />    return dirs;<br />  dirs.push_back(dir);<br />  while(true)<br />  {<br />    dir = fss.nextDirectory();<br />    if(dir.size() == 0)<br />      return dirs;<br />    dirs.push_back(dir);<br />  }<br />  return dirs;<br />}<br />//----&lt;<br /><br />bool Directory::create(const std::string& path)<br />{<br />  return ::CreateDirectoryA(path.c_str(), NULL) == 0;<br />}<br />//----&lt;<br /><br />bool Directory::exists(const std::string& path)<br />{<br />  DWORD dwAttrib = GetFileAttributesA(path.c_str());<br /><br />  return (dwAttrib != INVALID_FILE_ATTRIBUTES && <br />         (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));<br />}<br />//----&lt;<br /><br />bool Directory::remove(const std::string& path)<br />{<br />  return ::RemoveDirectoryA(path.c_str()) == 0;<br />}<br />//----&lt;<br /><br />std::string FileSystemSearch::firstFile(const std::string& path, const std::string& pattern)<br />{<br />  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);<br />  if(hFindFile != INVALID_HANDLE_VALUE)<br />  {<br />    if(!(pFindFileData-&gt;<br />      return pFindFileData-&gt;<br />    else<br />      while(::FindNextFileA(hFindFile, pFindFileData))<br />        if(!(pFindFileData-&gt;<br />          return pFindFileData-&gt;<br />  }<br />  return "";<br />}<br />//----&lt;<br /><br />std::string FileSystemSearch::nextFile()<br />{<br />  while(::FindNextFileA(hFindFile, pFindFileData))<br />    if(!(pFindFileData-&gt;<br />      return pFindFileData-&gt;<br />  return "";<br />}<br />//----&lt;<br /><br />std::string FileSystemSearch::firstDirectory(const std::string& path, const std::string& pattern)<br />{<br />  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);<br />  if(hFindFile != INVALID_HANDLE_VALUE)<br />  {<br />    if(pFindFileData-&gt;<br />      return pFindFileData-&gt;<br />    else<br />      while(::FindNextFileA(hFindFile, pFindFileData))<br />        if(pFindFileData-&gt;<br />          return pFindFileData-&gt;<br />  }<br />  return "";<br />}<br />//----&lt;<br /><br />std::string FileSystemSearch::nextDirectory()<br />{<br />  while(::FindNextFileA(hFindFile, pFindFileData))<br />    if(pFindFileData-&gt;<br />      return pFindFileData-&gt;<br />  return "";<br />}<br />//----&lt;<br /><br />#ifdef TEST_FILESYSTEM<br /><br />void title(const std::string& title, char ch='=')<br />{<br />  std::cout &lt;<br />  std::cout &lt;<br />}<br />int main(int argc, char* argv[])<br />{<br />  title("Demonstrate Path Class");<br /><br />  std::string fs = Path::fileSpec(".","temp.txt");<br />  std::cout &lt;<br /><br />  std::string path = Path::getPath(fs);<br />  std::cout &lt;<br />  <br />  std::string ffs = Path::getFullFileSpec(fs);<br />  std::cout &lt;<br />  <br />  std::string name = Path::getName(fs);<br />  std::cout &lt;<br /><br />  std::string ext = Path::getExt(fs);<br />  std::cout &lt;<br /><br />  std::string upper = Path::toUpper("temp.txt");<br />  std::cout &lt;<br /><br />  std::string lower = Path::toLower("Temp.Txt");<br />  std::cout &lt;<br />  std::cout &lt;<br /><br />  title("Demonstrate Directory class");<br /><br />  // Display contents of current directory<br /><br />  std::cout &lt;<br />  std::cout &lt;<br />  std::vector&lt;<br />  ///////////////////////////////////////////////////////<br />  // This works too<br />  // std::vector&lt;<br />  for(size_t i=0; i&lt;<br />    std::cout &lt;<br />  std::cout &lt;<br />  std::vector&lt;<br />  for(size_t i=0; i&lt;<br />    std::cout &lt;<br />  std::cout &lt;<br /><br />  // Display contents of non-current directory<br /><br />  std::cout &lt;<br />  currfiles = Directory::getFiles("c:/temp/", "*.txt");<br /><br />  // if we want fully qualified file names, we have to<br />  // set the current directory to the path on which the files<br />  // reside, if it isn't already so set<br /><br />  std::string currDir = Directory::getCurrentDirectory();<br />  Directory::setCurrentDirectory("c:/temp/");<br />  for(size_t i=0; i&lt;<br />    std::cout &lt;<br />  Directory::setCurrentDirectory(currDir);<br /><br />  // we have to restore the current directory so the<br />  // remaining tests work<br /><br />  // it's probably easier just to use Path::fileSpec(path, filename)<br />  // like this:<br /><br />  for (size_t i = 0; i&lt;<br />    std::cout &lt;<br /><br />  std::cout &lt;<br />  std::cout &lt;<br />  currdirs = Directory::getDirectories("c:/temp/");<br />  for(size_t i=0; i&lt;<br />    std::cout &lt;<br />  std::cout &lt;<br /><br />  // Create directory<br /><br />  title("Demonstrate FileInfo Class Operations", '=');<br />  std::cout &lt;<br /><br />  Directory::setCurrentDirectory(".");<br />  std::cout &lt;<br />  <br />  std::string fn1;<br />  if(argc &gt;<br />    fn1 = argv[1];<br />  else<br />    fn1 = "c:\\temp\\test.txt";<br />  FileInfo fi(fn1);<br /><br />  if(fi.good())<br />  {<br />    std::cout &lt;<br />    std::cout &lt;<br />    std::cout &lt;<br />    std::cout &lt;<br />    std::cout &lt;<br />    if(fi.isArchive())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isCompressed())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isDirectory())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isEncrypted())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isHidden())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isNormal())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isOffLine())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isReadOnly())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isSystem())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi.isTemporary())<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />  }<br />  else<br />    std::cout &lt;<br /><br />  std::string fn2;<br />  if(argc &gt;<br />  {<br />    fn1 = argv[1];<br />    fn2 = argv[2];<br />  }<br />  else<br />  {<br />    fn1 = "FileSystem.h";<br />    fn2 = "FileSystem.cpp";<br />  }<br />  FileInfo fi1(fn1);<br />  FileInfo fi2(fn2);<br />  if(fi1.good() && fi2.good())<br />  {<br />    if(fi1 == fi1)<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi1 &lt;<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi1 == fi2)<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi1 &lt;<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi1.smaller(fi2))<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    if(fi1.earlier(fi2))<br />      std::cout &lt;<br />    else<br />      std::cout &lt;<br />    std::cout &lt;<br />  }<br />  else<br />    std::cout &lt;<br /><br />  title("Demonstrate File class operations", '=');<br />  std::cout &lt;<br /><br />  // copy binary file from one directory to another<br /><br />  File me("../debug/filesystemdemo.exe");<br />  me.open(File::in, File::binary);<br />  std::cout &lt;<br />  if(!me.isGood())<br />  {<br />    std::cout &lt;<br />    std::cout &lt;<br />    std::cout &lt;<br />  }<br />  else<br />  {<br />    File you("c:/temp/fileSystemdemo.exe");<br />    you.open(File::out, File::binary);<br />    if(you.isGood())<br />    {<br />      while(me.isGood())<br />      {<br />        static size_t count = 0;<br />        Block b = me.getBlock(1024);<br />        you.putBlock(b);<br />        if (++count &lt;<br />        {<br />          std::cout &lt;<br />          std::cout &lt;<br />        }<br />        if (b.size() &lt;<br />        {<br />          std::cout &lt;<br />          std::cout &lt;<br />          std::cout &lt;<br />        }<br />      }<br />      std::cout &lt;<br />    }<br />  }<br /><br />  // save some filespecs of text files in a vector for File demonstrations<br /><br />  std::vector&lt;<br />  if(argc == 1)<br />  {<br />    std::cout &lt;<br />  }<br /><br />  for(int i=1; i&lt;<br />  {<br />    files.push_back(argv[i]);<br />  }<br />  files.push_back("FileSystem.cpp");                     // file not on current path<br />  files.push_back("../FileSystemDemo/FileSystem.cpp");   // file from project directory<br />  files.push_back("../FileSystemTest.txt");              // file in solution directory<br />  files.push_back("foobar");                             // doesn't exist<br /><br />  // open each file and display a few lines of text<br /><br />  for(size_t i=0; i&lt;<br />  {<br />    File file(files[i]);<br />    file.open(File::in);<br />    if(!file.isGood())<br />    {<br />      std::cout &lt;<br />      std::cout &lt;<br />      continue;<br />    }<br />    std::string temp = std::string("Processing file ") + files[i];<br />    title(temp, '-');<br />    for(int j=0; j&lt;<br />    {<br />      if(!file.isGood())<br />        break;<br />      std::cout &lt;<br />    }<br />    std::cout &lt;<br />  }<br />  std::cout &lt;<br /><br />  // read all lines of text file into string<br /><br />  title("testing File::readAll()", '-');<br />  std::cout &lt;<br />  File testAll("../FileSystemTest.txt");<br />  testAll.open(File::in);<br />  if (testAll.isGood())<br />  {<br />    std::string all = testAll.readAll();<br />    std::cout &lt;<br />  }<br />  testAll.close();<br /><br />  title("testing File::readAll(true)", '-');<br />  std::cout &lt;<br />  File testAllTrue("../FileSystemTest.txt");<br />  testAllTrue.open(File::in);<br />  if (testAllTrue.isGood())<br />  {<br />    std::string all = testAllTrue.readAll(true);<br />    std::cout &lt;<br />  }<br />  testAllTrue.close();<br /><br />  // test reading non-text files<br /><br />  title("test reading non-text files", '-');<br />  std::cout &lt;<br />  std::cout &lt;<br />  std::cout &lt;<br />  std::cout &lt;<br />  std::cout &lt;<br />  std::string testPath = "./debug";  // run from project directory (what Visual Studio does)<br />  if (!Directory::exists(testPath))<br />    testPath = ".";                  // run from solution debug directory<br />  std::vector&lt;<br />  for (auto file : testFiles)<br />  {<br />    try<br />    {<br />      std::string ext = Path::getExt(file);<br />      if (ext == "exe" || ext == "obj" || ext == "dll" || file == "run.dat")<br />      {<br />        /* reading binary file works, but generates a lot of garbage */<br />        /* I use run.dat to capture this output so including will make output confusing */<br /><br />        std::cout &lt;<br />        continue;<br />      }<br />      File test(file);<br />      test.open(File::in);  // open as text file<br />      std::cout &lt;<br />      if (test.isGood())<br />      {<br />        std::string text = test.readAll(true);<br />        std::cout &lt;<br />      }<br />      else<br />      {<br />        std::cout &lt;<br />      }<br />    }<br />    catch (std::exception& ex)<br />    {<br />      std::cout &lt;<br />    }<br />  }<br /><br />  // read text file and write to another text file<br /><br />  title("writing to c:/temp/test.txt", '-');<br />  File in("../FileSystemDemo/FileSystem.h");<br />  in.open(File::in, File::text);<br />  File out("c:/temp/test.txt");<br />  out.open(File::out, File::text);<br />  while(in.isGood() && out.isGood())<br />  {<br />    std::string temp = in.getLine();<br />    //std::cout &lt;<br />    out.putLine(temp);<br />    out.putLine("\n");<br />  }<br />  std::cout &lt;<br />  std::cout &lt;<br /><br />  // read and write buffers<br /><br />  title("reading and writing buffers");<br />  std::cout &lt;<br />  std::string fileIn = "../TestFileSystem/UnitTest.h";<br />  std::string fileOut = "../TestFileSystem/CopyOfUnitTest.h";<br />  File bufferIn(fileIn);<br />  bufferIn.open(File::in, File::binary);<br />  if (!bufferIn.isGood())<br />  {<br />    std::cout &lt;<br />      return 1;<br />  }<br />  else<br />  {<br />    std::cout &lt;<br />  }<br />  File bufferOut(fileOut);<br />  bufferOut.open(File::out, File::binary);<br />  if (!bufferOut.isGood())<br />  {<br />    std::cout &lt;<br />      return 1;<br />  }<br />  else<br />  {<br />    std::cout &lt;<br />  }<br />  std::cout &lt;<br />  const size_t bufLen = 124;<br />  File::byte buffer[bufLen];<br />  while (true)<br />  {<br />    size_t resultSize = bufferIn.getBuffer(bufLen, buffer);<br />    //std::cout &lt;<br />    std::string temp1(buffer, resultSize);<br />    std::cout &lt;<br />    //std::cout &lt;<br />    bufferOut.putBuffer(resultSize, buffer);<br />    if (resultSize &lt;<br />    {<br />      bufferIn.close();<br />      bufferOut.close();<br />      break;<br />    }<br />  }<br />  std::cout &lt;<br />}<br />#endif<br /></body>/html