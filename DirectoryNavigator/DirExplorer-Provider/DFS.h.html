<!Document html>
<html><head></head><body>#pragma once<br />/////////////////////////////////////////////////////////////////////<br />// DFS.h - Depth First Search using provider model                 //<br />// ver 1.2                                                         //<br />// Jim Fawcett, CSE687 - Object Oriented Design, Fall 2018         //<br />/////////////////////////////////////////////////////////////////////<br />/*<br />*  Package Operations:<br />*  -------------------<br />*  DFS implements Depth First Search, depending on its Provider to<br />*  implement branch and leaf operations.  <br />*<br />*  A directory provider has these corresponding parts:<br />*  - branch is a directory (holds files and subdirectories)<br />*  - leaf is a file<br />*  A graph provider would have these corresponding parts:<br />*  - branch is a vertex (holds edges)<br />*  - leaf is an edge (points to a single vertex)<br />*<br />*  The Provider is essentially an application's adapter that lets the <br />*  DFS instance be ignorant of the details of its operations.<br />*<br />*  Required Files:<br />*  ---------------<br />*  DFS.h, DFS.cpp   // DFS.cpp is not needed by applications<br />*  Provider.h<br />*<br />*  Maintenance History:<br />*  --------------------<br />*  ver 1.3 : 19 Aug 2018<br />*  - minor refactoring of code layout<br />*  - changed done() to use Provider's done<br />*  ver 1.2 : 16 Aug 2018<br />*  - changed pProvider_ member from pointer to Provider::IProvider<br />*    to std::shared_ptr&lt;<br />*  - set no recursion as default<br />*  ver 1.1 : 15 Aug 2018<br />*  - added functionality for passing search and reporting parameters<br />*    to its provider<br />*  ver 1.0 : 12 Aug 2018<br />*  - first release<br />*/<br />#include "Provider.h"<br /><br />namespace Search<br />{<br /><br />  template&lt;<br />  class DFS<br />  {<br />  public:<br />    using sPtrProv = std::shared_ptr&lt;<br /><br />    DFS(sPtrProv pProvider) : pProvider_(pProvider) {}<br />    virtual ~DFS() {}<br />    void setMaxItems(size_t maxItems);<br /><br />    void search();<br />    void find(sPtrProv pProvider);<br />    void recurse(bool doRecurse = true);<br /><br />  private:<br />    bool done();<br />    sPtrProv pProvider_ = nullptr;<br />    static size_t maxItems_;<br />    static bool recurse_;<br />  };<br /><br />  // define statics<br />  size_t DFS&lt;<br />  bool DFS&lt;<br /><br />  //----&lt;<br /><br />  template&lt;<br />  void DFS&lt;<br />  {<br />    maxItems_ = maxItems;<br />  }<br />  //----&lt;<br /><br />  template&lt;<br />  void DFS&lt;<br />  {<br />    recurse_ = doRecurse;<br />  }<br />  //----&lt;<br />  /*<br />  *  pProvider_ is a std::shared_ptr&lt;<br />  *  to a DirProvider<br />  */<br />  template&lt;<br />  void DFS&lt;<br />  {<br />    find(pProvider_);<br />  }<br />  //----&lt;<br />  /*<br />  *  There are two Providers that implement the IProvider interface:<br />  *  - FileProvider handles all file operations<br />  *  - DirProvider handles all directory operations<br />  *  In order to navigate, you have to hand find() a DirProvider,<br />  *  otherwise you just display the input file name.  That has no<br />  *  children, so there won't be any recursion.<br />  */<br />  template&lt;<br />  void DFS&lt;<br />  {<br />    if (pProvider-&gt;<br />      return;<br />    pProvider-&gt;<br />    for (auto pProv : *(pProvider-&gt;<br />    {<br />      if (recurse_)<br />        find(pProv);<br />      else<br />        pProv-&gt;<br />    }<br />  }<br />  //----&lt;<br /><br />  template&lt;<br />  bool DFS&lt;<br />  {<br />    pProvider_-&gt;<br />  }<br />}<br /></body>/html