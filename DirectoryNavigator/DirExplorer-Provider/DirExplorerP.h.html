<!Document html>
<html><head></head><body>#pragma once<br />/////////////////////////////////////////////////////////////////////<br />// DirExplorerP.h - Provider-based directory explorer              //<br />// ver 1.3                                                         //<br />// Jim Fawcett, CSE687 - Object Oriented Design, Fall 2018         //<br />/////////////////////////////////////////////////////////////////////<br />/*<br />* Package Operations:<br />* -------------------<br />* DirExplorerP provides a class, of the same name, that executes a<br />* depth first search of a directory tree rooted at a specified path.<br />*<br />* We call this a "Provider-based Directory Explorer" because, it carries<br />* out its assigned responsibilities using the facilities of the DFS<br />* and Provider packages.  <br />*<br />* The Provider is application specific, deciding what to do when a<br />* file or a directory is encountered in DFS.  <br />*<br />* DFS controls how the search is executed.  All that the DirExplorerP<br />* package needs to do is to extract parameters from the command line<br />* and, using them, start DFS.<br /><br />* This is an improvement over DirExplorerN because the application<br />* does not need to change any part of the DirExplorerP or DFS classes.<br />*<br />* Other projects in this solution do just that, in different ways.<br /><br />* - DirExplorer-Naive:<br />*     Implements basic processing well, but applications have to<br />*     change its code to affect how files and directories are<br />*     handled.<br />* - DirExplorer-Template:<br />*     Applications provide template class parameters to define file<br />*     and directory processing.<br />* - DirExplorer-Inheritance:<br />*     Applications subclass DirExplorerI, overriding virtual functions<br />*     doFile, doDir, and doQuit to define how files and directories<br />*     are handled, and whether processing should terminate before<br />*     visiting all directories.<br />* - DirExplorer-Events:<br />*     Applications use Event Interfaces, published by DirExplorerE,<br />*     by subscribing event-handler functions, and control terminate<br />*     processing using a plug-in interface.<br />* - DirExplorer-Provider:<br />*     Applications build a file system provider that implements<br />*     an IProvider interface published by DirExplorerP.<br />*<br />* We'll be using this solution to illustrate techniques for building<br />* flexible software.<br />*<br />* Required Files:<br />* ---------------<br />* DirExplorerP.h, DirExplorerP.cpp<br />* Provider.h<br />* DFS.h<br />* FileSystem.h, FileSystem.cpp      // Directory and Path classes<br />* StringUtilities.h                 // Title function<br />* CodeUtilities.h                   // ProcessCmdLine class<br />*<br />* Maintenance History:<br />* --------------------<br />* ver 1.3 : 18 Aug 2018<br />* - moved methods to inlines below class declaration<br />* - eliminated some unnecessary state in DirExplorerP<br />* ver 1.2 : 16 Aug 2018<br />* - fixed bug reporting final status<br />* ver 1.1 : 16 Aug 2018<br />* - made no recursion default, added option /s for recursion<br />* ver 1.0 : 15 Aug 2018<br />* - first release<br />*<br />*/<br />#include &lt;<br />#include &lt;<br />#include "../FileSystem/FileSystem.h"<br />#include "Provider.h"<br />#include "DFS.h"<br /><br />namespace FileSystem<br />{<br />  class DirExplorerP<br />  {<br />  public:<br />    using Patterns = std::vector&lt;<br /><br />    static std::string version() { return "ver1.3"; }<br /><br />    DirExplorerP(const std::string& path);<br /><br />    // configure processing<br /><br />    void addPattern(const std::string& patt);<br />    void hideEmptyDirectories(bool hide);<br />    void maxItems(size_t numFiles);<br />    void showAllInCurrDir(bool showAllCurrDirFiles);<br />    void recurse(bool doRecurse = true);<br />    <br />    void search();     // navigate using DFS instance,<br />                       // which uses Provider<br />    void showStats(); <br /><br />  private:<br />    // use dynamic_cast to access DirProvider's extended interface<br /><br />    std::shared_ptr&lt;<br />    {<br />      std::shared_ptr&lt;<br />        = std::dynamic_pointer_cast&lt;<br />      return pDirProv;<br />    }<br />    // Provider contains all knowledge about the file system<br /><br />    Provider::IProvider::sPtrProv pProvider_;<br />    <br />    std::string path_;       // pass to Provider<br />    size_t maxItems_ = 0;    // pass to temp DFS instance<br />    bool recurse_ = false;   // pass to temp DFS instance<br />  };<br /><br />  //----&lt;<br /><br />  DirExplorerP::DirExplorerP(const std::string& path) <br />    : path_(path), pProvider_(new Provider::DirProvider(path)) { }<br /><br />  //----&lt;<br /><br />  void DirExplorerP::addPattern(const std::string& patt)<br />  {<br />    auto pDirProvider = dirProvider(pProvider_);<br />    if (pDirProvider)<br />    {<br />      Patterns& provPatterns = pDirProvider-&gt;<br />      if (provPatterns.size() == 1 && provPatterns[0] == "*.*")<br />        provPatterns.pop_back();<br />      provPatterns.push_back(patt);<br />    }<br />  }<br />  //----&lt;<br /><br />  void DirExplorerP::hideEmptyDirectories(bool hide)<br />  {<br />    //hideEmptyDir_ = hide;<br />    auto pDirProvider = dirProvider(pProvider_);<br />    if (pDirProvider)<br />      pDirProvider-&gt;<br />  }<br />  //----&lt;<br /><br />  void DirExplorerP::maxItems(size_t numFiles)<br />  {<br />    //maxItems_ = numFiles;<br />    auto pDirProvider = dirProvider(pProvider_);<br />    if (pDirProvider)<br />      pDirProvider-&gt;<br />  }<br />  //----&lt;<br /><br />  void DirExplorerP::showAllInCurrDir(bool showAllCurrDirFiles)<br />  {<br />    //showAll_ = showAllCurrDirFiles;<br />    auto pDirProvider = dirProvider(pProvider_);<br />    if (pDirProvider)<br />      pDirProvider-&gt;<br />  }<br />  //----&lt;<br /><br />  //bool DirExplorerP::showAllInCurrDir()<br />  //{<br />  //  auto pDirProvider = dirProvider(pProvider_);<br />  //  if (pDirProvider)<br />  //    showAll_ = pDirProvider-&gt;<br />  //  return showAll_;<br />  //}<br />  //----&lt;<br /><br />  void DirExplorerP::recurse(bool doRecurse)<br />  {<br />    recurse_ = doRecurse;<br />  }<br />  //----&lt;<br /><br />  void DirExplorerP::search()<br />  {<br />    pProvider_-&gt;<br />    Search::DFS&lt;<br />    dfs.setMaxItems(maxItems_);<br />    dfs.recurse(recurse_);<br />    dfs.search();<br />  }<br />  //----&lt;<br /><br />  void DirExplorerP::showStats()<br />  {<br />    size_t fileCount = pProvider_-&gt;<br />    size_t dirCount = pProvider_-&gt;<br />    std::cout &lt;<br />    if (pProvider_-&gt;<br />    {<br />      std::cout &lt;<br />    }<br />  }<br />}<br /></body>/html